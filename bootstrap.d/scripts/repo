#!/usr/bin/env bash
# repo - ghq-backed clone + edit helper with work/home routing
# Place in ~/.local/bin/repo and `chmod +x ~/.local/bin/repo`
# Requires: ghq, fzf (for `repo edit`)
set -euo pipefail

# -------- Configuration (edit as you like) --------
DEV_ROOT="${XDG_DEV_HOME:-$HOME/dev}"   # base dir (use XDG_DEV_HOME if exported)
DEV_HOME="${DEV_HOME_ROOT:-$DEV_ROOT/home}"
DEV_WORK="${DEV_WORK_ROOT:-$DEV_ROOT/work}"
GH_HOST="github.com"
WORK_ORGS="${REPO_WORK_ORGS:-}"        # comma-separated list: e.g. "fielmann,acme-inc"
# -------- end configuration --------

# Helpers
have() { command -v "$1" >/dev/null 2>&1; }
msg()  { printf '==> %s\n' "$*" >&2; }

usage() {
  cat <<EOF
repo - helper (ghq-backed, defaults to SSH for owner/repo)

Usage:
  repo clone <owner/repo> [--profile work|home]
  repo clone <https://...> [--profile work|home]
  repo edit                # fuzzy select a local repo and enter it
  repo list                # list local repos (ghq list)

Notes:
  - Default roots: \$DEV_HOME and \$DEV_WORK under \$XDG_DEV_HOME or ~/dev
  - owner/repo clones default to SSH (git@github.com:owner/repo.git)
  - If you pass a full URL (https:// or git@) it is used as-is
EOF
  exit 2
}

is_url() { [[ "$1" =~ ^(https?://|git@) ]]; }

# Given owner/repo or URL; return owner and repo (no .git)
parse_owner_repo() {
  local arg="$1"
  arg="${arg#github:}"
  arg="${arg%.git}"
  printf '%s\n' "$arg"
}

choose_root() {
  local owner="$1" explicit="$2"
  if [ -n "$explicit" ]; then
    case "$explicit" in
      work) echo "$DEV_WORK"; return;;
      home) echo "$DEV_HOME"; return;;
      *) echo "$DEV_HOME"; return;;
    esac
  fi

  # auto-detect by WORK_ORGS
  IFS=',' read -ra ORGS <<< "$WORK_ORGS"
  for o in "${ORGS[@]}"; do
    [ -z "$o" ] && continue
    if [ "$o" = "$owner" ]; then
      echo "$DEV_WORK"; return
    fi
  done
  echo "$DEV_HOME"
}

# clone flow: if URL, pass to ghq get; if owner/repo, build SSH url and use ghq get -p
clone_remote() {
  local remote="$1" profile="$2"

  if is_url "$remote"; then
    msg "Cloning explicit URL: $remote"
    GHQ_ROOT="$DEV_ROOT" ghq get "$remote"
    return
  fi

  # owner/repo shorthand
  if [[ "$remote" =~ ^[^/]+/[^/]+$ ]]; then
    local owner_repo
    owner_repo="$(parse_owner_repo "$remote")"
    local owner="${owner_repo%%/*}"
    local root
    root="$(choose_root "$owner" "$profile")"
    mkdir -p "$root"
    local ssh_url="git@${GH_HOST}:${owner_repo}.git"
    msg "Cloning shorthand via SSH: $ssh_url -> root $root"
    # ghq picks GHQ_ROOT env var for destination root
    GHQ_ROOT="$root" ghq get -p "$ssh_url"
    return
  fi

  # otherwise fallback to ghq get raw
  msg "Fallback cloning via ghq: $remote"
  GHQ_ROOT="$DEV_ROOT" ghq get "$remote"
}

# find local repos (search both home & work roots), return list (repo path)
find_local_repos() {
  # find .git directories and map to repo root; ignore node_modules and hidden vendor dirs
  local -a roots=("$DEV_HOME" "$DEV_WORK")
  local -a out=()
  for r in "${roots[@]}"; do
    [ -d "$r" ] || continue
    while IFS= read -r d; do
      out+=("${d%/.git}")
    done < <(find "$r" -type d -name .git -prune 2>/dev/null | sed 's/\/\.git$//')
  done
  printf '%s\n' "${out[@]}"
}

edit_repo() {
  if ! have fzf; then
    echo "fzf is required for 'repo edit'." >&2
    exit 1
  fi
  mapfile -t repos < <(find_local_repos)
  if [ ${#repos[@]} -eq 0 ]; then
    echo "No repositories found under $DEV_HOME or $DEV_WORK." >&2
    exit 1
  fi
  local choice
  choice=$(printf '%s\n' "${repos[@]}" | fzf --ansi --no-hscroll --preview 'git -C {} status --short 2>/dev/null | sed -n "1,200p"' --height=40% --layout=reverse)
  if [ -z "$choice" ]; then
    msg "cancelled"
    exit 0
  fi
  msg "Entering: $choice"
  cd "$choice"
  exec ${SHELL:-/bin/bash}
}

list_repos() {
  if ! have ghq; then
    echo "ghq is required; install it first." >&2
    exit 1
  fi
  GHQ_ROOT="$DEV_ROOT" ghq list
}

# dispatch
case "${1:-}" in
  clone)
    [ -n "${2:-}" ] || usage
    if ! have ghq; then
      echo "ghq not found. Install ghq (mise or package manager) and retry." >&2
      exit 1
    fi
    remote="$2"; shift 2 || true
    profile=""
    while [ $# -gt 0 ]; do
      case "$1" in
        -p|--profile) profile="$2"; shift 2 ;;
        *) shift ;;
      esac
    done
    clone_remote "$remote" "$profile"
    ;;
  edit)
    edit_repo
    ;;
  list)
    list_repos
    ;;
  *)
    usage
    ;;
esac

